# Formal Languages, Grammars, and Parsing

## Formal language
- **alphabet:** finite set $\Sigma$ of symbols
- **string:** finite sequence of symbols
    - empty string $\epsilon$
    - $\Sigma^*$ - set of all strings over $\Sigma$, including empty string
    - $\Sigma^+$ - set of all non-empty strings over $\Sigma$
- **language:** set of strings $L \subseteq \Sigma^*$

## Formal grammars
- $G = (N, T, S, P)$
    - finite set of **non-terminal symbols** N
    - finite set of **terminal symbols** T
    - starting non-terminal symbol $S \in N$
    - finite set of **productions** P
    - describes a language $L \subseteq T^*$
- **production:** $x \rightarrow y$
    - x is a non-empty sequence of terminals and non-terminals
    - y is a sequence of terminals and non-terminals
- applying a production: $uxw \Rightarrow uyw$

### Example: non-negative integers
```
N = {I, D}
T = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
S = I
P = {
    I -> D,
    I -> DI,
    D -> 0,
    D -> 1,
    D -> 2,
    D -> 3,
    D -> 4,
    D -> 5,
    D -> 6,
    D -> 7,
    D -> 8,
    D -> 9
}
```

- 000 is in the language: `I -> DI -> DDI -> DDD -> 0DD -> 00D -> 000`

### Common notation
- just the grammar notation
- starting non-terminal is first
```
I -> D | DI
D -> 0 | 1 | 2 | ... | 9
```

## Languages and grammars
- string derivation
    - $w_1 \Rightarrow w_2 \Rightarrow ... \Rightarrow w_n$
    - denoted $w_1 \Rightarrow^* w_n$
    - if n > 1, non-empty derivation sequence: $w_1 \Rightarrow^+ w_n$
- language generated by a grammar
    - $L(G) = {w \in T^* | S \Rightarrow^+ w}$
- Chomsky hierarchy:
    - fundamental theoretical characterization
    - regular languages < context free languages < context sensitive languages < unrestricted languages
    - regular languages in PL: for lexical analysis
    - context-free languages in PL: for syntax analysis
    - linear-time parsers can be written for a subset of context free languages

## Regular languages
- used in scanners
- language operations:
    - union
    - concatenation (all ab such that a in L and b in M)
    - $L^0 = {\epsilon}$ and $L^i = L^{i-1}L$
    - closure: $L^* = L^0 \cup L^1 ...$
    - positive closure: $L^+ = L^1 \cup L^2 ...$
- regular expressions: notation to express languages constructed with these operations
    - example: $(0|1|2|...|9)^+$

### Regular expressions
- **regular expression:**
    - empty string
    - any symbol from alphabet
    - if r and s are regular expressions, so are $r|s$, $rs$, $r^*$, $r^+$, $r?$, and $(r)$
        - $r?$ is shorthand for $(\epsilon | r)$
    - `*/+/?` have higher precedence than concatenation
    - concatenation has higher precedence than `|`
    - all are left-associative
- each regular expression $r$ defines a language $L(r)$
    - ![[Pasted image 20240112131606.png]]

### Regular languages
- all productions are $A \rightarrow wB$ and $A \rightarrow w$
    - A and B are non-terminals
    - w is a sequence of terminals
    - this is a **right-regular grammar**
- or all productions are $A \rightarrow Bw$ and $A \rightarrow w$
    - **left-regular grammar**
- equivalent formalisms:
    - regular grammars
    - regular expressions
    - nondeterministic finite automata
    - deterministic finite automata

### Uses of regular languages
- lexical analysis
- pattern matching

## Context-free languages
- every regular language is a context-free language
    - but not necessarily vice-versa
- $A \rightarrow w$
    - A *must* be a single non-terminal

### Backus-Naur form (BNF)
![[Pasted image 20240117125442.png]]

### Derivation tree for a string
- aka **parse tree** or **concrete syntax tree**
- leaf nodes are terminals
- inner nodes are non-terminals
- root node is starting non-terminal
- leaf nodes, from left to right, are the string
- use depth-first traversal to get this string
    - always visiting the leftmost unexplored branch
![[Pasted image 20240117125710.png]]

### Equivalent derivation sequence
- derive the same string with different trees

## Ambiguous grammars
- multiple different parse trees for same string
- allow compilers freedom to optimize
    - different parse trees may perform differently
- to remove ambiguity: add non-terminals
- **precedence:** how to decide operands of operators without parenthesis
- **associativity:** what order to evaluate operators with same precedence

![[Pasted image 20240117131521.png]]

```
// this doesn't work for 1+2+3
expr ::= term + term
term ::= factor * factor
factor ::= (expr) | id
```

```
// this does work for 1+2+3
// but not for 1*2*3
expr ::= expr + expr | term
term ::= factor * factor
factor ::= (expr) | id
```

```
// this works but is still ambiguous!
// 1+2+3 has 2 parse trees
expr ::= expr + expr | term
term ::= term * factor | factor
factor ::= (expr) | id
```

- the way the rules are written (+ at top,  \* in middle, parenthesis at bottom) create the precedence behavior
- symmetry around the operator causes ambiguity
    - Unless they're terminals
    - breaking symmetry affects associativity
- want left-to-right associativity for `+`
    - want leftmost `+` to evaluate first (be lower on tree)
    - so keep the recursive `expr` on the left side (replace right side with `term`) to force that side to end up lower on the tree

```
// this is the correct answer
expr ::= expr + term | term
term ::= term * factor | factor
factor ::= (expr) | id
```

### Dangling else problem
![[Pasted image 20240117132832.png]]
![[Pasted image 20240117133310.png]]
## Horrible language idea
- everything is just the parse tree
```
program: 
```