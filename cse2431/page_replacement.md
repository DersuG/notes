# Page replacement

## Inverted page table (???)

## Demand paging
- don't bring pages into main memory until they're needed
- algorithm:
    - page fault happens
    - check if virtual address is valid
    - check if it's cached in memory, skip to 6 if so
    - find a free page frame
    - map address to disk block # and fetch disk block into page frame
    - once the page is in main memory, add virtual memory mapping for page frame
    - restart the faulted instruction
- question: can bring in a page a bit earlier?
- **reference string:** the memory reference sequence generated by a program
- **paging:** moving pages from disk to memory
- **pollution:** bringing in useless pages/lines
## Optimal algorithm
- optimal strategy: replace the page that will not be used again the farthest time in the future
    - impractical
    - basis for comparison for other algorithms
    - requires knowing the entire reference string
- to determine which page to replace, look into the future to see which page won't be needed for the longest
    - e.g. replacement string = `ABCDABEABCDE` and there's 3 page frames:
        - `(A)` (fault)
        - `(B)A` (fault)
        - `(C)BA` (fault)
        - `(D)BA` (fault) (`C` is replaced because it won't be used for a while)
        - `DB(A)` (no fault)
        - `D(B)A` (no fault)
        - `(E)BA` (fault) (`D` is replaced because it won't be used for a while)
        - `EB(A)` (no fault)
        - `E(B)A` (no fault)
        - `(C)EB` (fault) (we can fall back to LRU here)
        - `(D)CE` (fault)
        - `DC(E)` (no fault)

## FIFO algorithm
- use a FIFO queue
- e.g. for replacement string `ABCDABEABCDE`:
    - `(A)`
    - `(B)A`
    - `(C)BA`
    - `(D)CB`
    - `(A)DC`
    - `(B)AD`
    - `(E)BA`
    - `EB(A)`
    - `E(B)A`
    - `(C)EB`
    - `(D)CE`
    - `DC(E)`
- not as efficient because we only care about initial access time, not subsequent ones

## Belady's anomaly (for FIFO)
- FIFO with 4 physical pages
- as # of page frames increases, so does the fault rate

## LRU algorithm
- like FIFO, but pages are moved to the front on hit
- tracking recency requires large overhead

## NRU algorithm
- (not recently used)
- approximation of LRU
- R and M bits:
    - R = 1 if recently referenced, 0 otherwise
    - M = 1 if dirty, 0 if clean
    - set by hardware
- page classes via R and M bits (R, M):
    - (0, 0) = not recently referenced and clean
    - (0, 1) = not recently referenced but dirty
    - (1, 0) = referenced but clean
    - (1, 1) = referenced and dirty
- algorithm:
    - select a page from the lowest class
    - if conflict, use random or FIFO
- OS periodically clears the R bit

## NFU algorithm and aging counter algorithm
- (not frequently used)
- simpler implementation:
    - each page has a software counter
    - the R bit is periodically added to the counter
    - the page with the lowest counter is the least frequently used
    - use FIFO to break ties
- aging counter implementation:
    - an approximation for LRU
    - right-shift the counter by 1 bit and add the R bit to the leftmost
    - `00110011` would be accessed more frequently than `00010111`

## Second chance and clock algorithm
- each page has a reference bit which is set whenever the page is accessed
- pages are kept in FIFO order
- second chance algorithm:
    - start from the head of FIFO
    - find the first page with an unset reference bit, this is the page to evict
    - unset all the reference bits of the pages that were passed
- clock algorithm:
    - linked list is circular
    - use a hand that points to a page, and rotates clockwise to check each page according to the same process as the second chance algorithm
## Working set
- **working set:** set of pages used in the *k* most recent memory references
- use a sliding window of the working set size and check all page refs
- tracking working set is expensive
    - use virtual CPU time to approximate (pages referenced during last *T* seconds of virtual CPU time)
- working set replacement:
    - approximate working set model using a timer, reference bits, and age (in pte)
    - set timer to interrupt periodically to clear reference bit
    - once a page is needed, remove pages that have not been referenced and old enough (>*T*) to the outside of working set

![[Pasted image 20231102155347.png]]

## WSClock algorithm
- used very widely (linux)
- maintain a circular list like the clock algorithm
- pages track time of last use, reference bits, and dirty bits
- if the hand points to a page with a set reference bit, unset it and update the time of last use
- if the hand points to a page with an unset reference bit, check if it's in the working set window
    - if not, but it's clean, replace it
    - if not, and it's dirty, request write to disk but move on to the next page
- repeat

## Design issue: allocation policies
- local page replacement
    - each process has a fixed frame allocation
- global page replacement
    - a process's frame allocation dynamically changes
- as the number of allocated page frames passes a certain threshold, the page fault rate drops dramatically

## Design issue: load control
- to avoid thrashing
- if working set size increases and no page frame is free, suspend the process and release all its pages
- if # of free pages > working set of some suspended process, reactivate it and map in all its working set

## Design issue: page size
- smaller pages:
    - locality of reference tends to be small
    - less fragmentation
    - large page table
- larger pages:
    - small page table
    - I/O transfers have high seek time, so better to transfer more data per seek
    - internal fragmentation
